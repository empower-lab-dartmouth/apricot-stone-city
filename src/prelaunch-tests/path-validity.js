"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.allPathsAreValid = void 0;
var util_functions_1 = require("../core/util/util-functions");
var state_manager_1 = require("../core/convo-engine/state-manager");
var Either_1 = require("fp-ts/lib/Either");
var logging_1 = require("../core/util/logging");
var Option_1 = require("fp-ts/lib/Option");
var allNestedModules = function (rootModule) {
    var visitedPathsAndModules = new Set();
    var modulesToVisit = [
        { path: [rootModule.id], module: rootModule },
    ];
    var _loop_1 = function () {
        var currentPathAndModule = modulesToVisit.pop();
        if (currentPathAndModule === undefined) {
            throw new Error("Unreachable null-check error in path validity test. This indicates a problem with the test");
        }
        visitedPathsAndModules.add(currentPathAndModule);
        var currentPath = currentPathAndModule.path, currentModule = currentPathAndModule.module;
        Object.values(currentModule.submodules).forEach(function (submodule) {
            var newPath = __spreadArray(__spreadArray([], currentPath, true), [submodule.id], false);
            modulesToVisit.push({
                path: newPath,
                module: submodule
            });
        });
    };
    while (modulesToVisit.length > 0) {
        _loop_1();
    }
    return visitedPathsAndModules;
};
var pathFromActon = function (action) {
    switch (action.type) {
        case 'start-convo-segment':
            return [action.path];
        default:
            return [];
    }
};
var allPathsFromActions = function (actions) {
    return actions.map(pathFromActon).reduce(util_functions_1.concatArraysReducer, []);
};
var allPathsFromChoice = function (choice) {
    return choice.logic
        .map(function (logic) {
        // De-duplication here, because the `otherwise` case is auto generated by the logic constructor if no `if` statement is specified
        if (logic._compiledWithoutConditional) {
            return __spreadArray([], allPathsFromActions(logic["do"]), true);
        }
        else {
            return __spreadArray(__spreadArray([], allPathsFromActions(logic["do"]), true), allPathsFromActions(logic.otherwise), true);
        }
    })
        .reduce(util_functions_1.concatArraysReducer, []);
};
var allPathsFromChoices = function (choices) {
    return choices.map(allPathsFromChoice).reduce(util_functions_1.concatArraysReducer, []);
};
var convoSegmentPathConstructor = function (parentModules, id) { return ({
    parentModules: parentModules,
    id: id
}); };
// Does not consider nested paths
var allPathsFromModule = function (pathAndModule) {
    return Object.values(pathAndModule.module.convoSegments)
        .map(function (convoSegment) {
        var pathValues = allPathsFromChoices(convoSegment.choices);
        return pathValues.map(function (pathValue) { return ({
            pathValue: pathValue,
            pathInstantiation: convoSegmentPathConstructor(pathAndModule.path, convoSegment.id)
        }); });
    })
        .reduce(util_functions_1.concatArraysReducer, []);
};
var allPathsFromModuleAndItsSubmodules = function (rootModule) {
    var allModules = allNestedModules(rootModule);
    return Array.from(allModules)
        .map(allPathsFromModule)
        .reduce(util_functions_1.concatArraysReducer, []);
};
var pathIsValid = function (root, currentPath, testPath) {
    return (0, Either_1.fold)(function (error) { return false; }, function (value) { return true; })((0, state_manager_1.safelyGetConvoSegment)(root, testPath, currentPath));
};
var pathLookupResultFromPathAndInstantiation = function (rootModule) { return function (pathAndInstatiation) { return (__assign(__assign({}, pathAndInstatiation), { pathIsValid: pathIsValid(rootModule, pathAndInstatiation.pathInstantiation, pathAndInstatiation.pathValue) })); }; };
var allPathsAreValid = function (config) {
    logging_1["default"].debug("~~~~~> Checking that all module paths are valid");
    var flatmapPathsAndConvoSegmentInstantiations = allPathsFromModuleAndItsSubmodules(config.rootModule);
    var pathLookupCurried = pathLookupResultFromPathAndInstantiation(config.rootModule);
    var lookupResults = flatmapPathsAndConvoSegmentInstantiations.map(pathLookupCurried);
    var invalidPaths = lookupResults.filter(function (lookupResult) { return !lookupResult.pathIsValid; });
    var delimeter = "=======";
    if (invalidPaths.length > 0) {
        logging_1["default"].error("The following paths are invalid!");
        invalidPaths.forEach(function (invalidPath) {
            logging_1["default"].error(delimeter, "invalid path ", invalidPath.pathValue);
            logging_1["default"].debug("For reference, this path is defined in the convo segment", invalidPath.pathInstantiation);
        });
        return (0, Option_1.some)(Error("Invalid path in module definition! Please fix this before running the chatbot server."));
    }
    else {
        logging_1["default"].debug("~~~~~> All paths are valid!");
        return Option_1.none;
    }
};
exports.allPathsAreValid = allPathsAreValid;
